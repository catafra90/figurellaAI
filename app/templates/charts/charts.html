{% extends "base.html" %}

{% block extra_head %}
<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; }
  #charts-main {
    position:absolute; top:64px; bottom:44px; left:0; right:0;
    display:flex; overflow:hidden;
  }
  #charts-wrapper { position:relative; width:100%; height:100%; overflow:hidden; }

  .panel {
    background:white; border-radius:0.75rem;
    box-shadow:0 0 16px 4px rgba(0,0,0,.15);
    padding:1rem; height:100%; overflow:auto; box-sizing:border-box;
  }
  #chart-panel.panel { padding:0; }

  /* Sidebar */
  #client-panel{
    position:absolute; top:0; bottom:0; left:0; width:200px;
    display:flex; flex-direction:column; background:white; z-index:1000;
    transition:width .2s, background .2s;
  }
  #client-panel.collapsed{ width:60px; background:#f3f4f6; }
  #client-panel .mb-2, #client-panel .px-4, #client-panel input, #client-panel .filter-row, #client-panel table {
    transition:opacity .2s;
  }
  #client-panel.collapsed .mb-2,
  #client-panel.collapsed .px-4,
  #client-panel.collapsed input,
  #client-panel.collapsed .filter-row,
  #client-panel.collapsed table { opacity:0; pointer-events:none; }

  #client-panel table { width:100%; border-collapse:collapse; margin:0; }
  #client-panel td { white-space:nowrap; padding:.5rem; cursor:pointer; }
  #client-panel thead { display:none; }

  /* Hide Date Created (2), Email (4), Phone (5) */
  #client-panel th:nth-child(2), #client-panel td:nth-child(2),
  #client-panel th:nth-child(4), #client-panel td:nth-child(4),
  #client-panel th:nth-child(5), #client-panel td:nth-child(5) { display:none; }

  /* Divider */
  .sidebar-divider{
    position:absolute; top:0; bottom:0; left:200px; width:8px; cursor:ew-resize;
    display:flex; align-items:center; justify-content:center; z-index:1001; background:transparent; transition:left .2s;
  }
  #client-panel.collapsed ~ .sidebar-divider{ left:60px !important; }
  .sidebar-divider i{ transform:rotate(90deg); font-size:1.25rem; color:rgba(0,0,0,.2); }

  /* Chart area */
  #chart-panel{
    position:absolute; top:0; bottom:0; left:200px; right:0;
    display:flex; align-items:flex-start; overflow:hidden; box-sizing:border-box; transition:left .2s;
  }
  #client-panel.collapsed ~ #chart-panel{ left:60px !important; }

  .card-divider{ flex:0 0 8px; cursor:col-resize; display:flex; align-items:center; justify-content:center; z-index:500; }
  .card-divider i{ font-size:1.25rem; color:rgba(0,0,0,.2); }

  .chart-card{
    position:relative; flex:1 1 0; min-width:0; display:flex; flex-direction:column;
    background:white; border-radius:.75rem; box-shadow:0 0 8px rgba(0,0,0,.1); overflow:hidden; box-sizing:border-box;
  }
  .scale-target{ transform-origin:top left; width:100%; height:100%; }
  .scale-content{ display:flex; flex-direction:column; width:100%; height:100%; }
  .chart-header{ background:#1f2937; color:#fff; display:flex; justify-content:space-between; align-items:center; padding:.5rem 1rem; flex-shrink:0; }
  .chart-close{ background:none; border:none; color:#fff; font-size:1.25rem; cursor:pointer; }
  .chart-body{ flex:1; display:flex; flex-direction:column; overflow:auto; }
  .chart-card.editing .chart-body{ outline:2px dashed #ec4899; outline-offset:-4px; }

  @keyframes headerFlash { 0%{background:#f59e0b;} 100%{background:#1f2937;} }
  .chart-header.flash { animation: headerFlash .8s ease; }

  /* Small spacing for flags next to names */
  .client-flags { margin-left:.25rem; }
  .client-flags > span { margin-left:.1rem; }

  /* Hide scrollbars for smoother scale container */
  .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  .hide-scrollbar::-webkit-scrollbar { display: none; }

  /* Visual state for Nutrition / Focus pills inside chart */
  .flag-group .flag-btn.btn-on { background:#ec4899 !important; color:#ffffff !important; box-shadow:0 6px 16px rgba(236,72,153,.35) !important; }
  .flag-group .flag-btn.btn-off { background:#e5e7eb !important; color:#111827 !important; box-shadow:none !important; }
</style>
{% endblock %}

{% block content %}
<main id="charts-main">
  <div id="charts-wrapper">

    <!-- Sidebar -->
    <div id="client-panel" class="panel">
      <div class="flex items-center mb-2">
        <i class="bi bi-bar-chart-fill text-2xl text-figurella"></i>
        <h1 class="text-2xl font-bold text-figurella ml-2">Charts</h1>
      </div>

      <div class="px-4 pb-2">
        <input id="clientSearch" placeholder="Filter‚Ä¶" class="w-full h-6 text-xs placeholder-gray-400 border border-gray-300 rounded px-2 focus:outline-none focus:ring-1 focus:ring-figurella" autocomplete="off">
      </div>

      <div class="filter-row px-4 pb-2">
        <label class="text-xs flex items-center select-none">
          <input id="onlyCurrent" type="checkbox" checked class="mr-2"> Only ‚ÄúCurrent client‚Äù
        </label>
      </div>

      <div class="overflow-y-auto" style="flex:1">
        <table>
          <thead>
            <tr>
              {% for col in columns %}<th>{{ col }}</th>{% endfor %}
            </tr>
          </thead>
          <tbody>
            {% for row in data|sort(attribute=columns[0]) %}
              {% set nutri_flag = row.get('Nutrition Flag') or row.get('NutritionFlag') or row.get('nutrition_flag') %}
              {% set focus_flag = row.get('Focus Case Flag') or row.get('FocusFlag') or row.get('focus_flag') %}

              <tr data-status="{{ row['Status']|lower }}">
                {% for col in columns %}
                  {% if loop.first %}
                    <td class="client-name text-figurella truncate" data-name="{{ row[col] }}">
                      <span class="client-name-text">{{ row[col] }}</span>
                      <span class="client-flags">
                        {% if nutri_flag and nutri_flag != 'No' %}<span title="Nutrition">üçé</span>{% endif %}
                        {% if focus_flag and focus_flag != 'No' %}<span title="Focus Case">üéØ</span>{% endif %}
                      </span>
                    </td>
                  {% else %}
                    <td>{{ row[col] }}</td>
                  {% endif %}
                {% endfor %}
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </div>

    <div class="sidebar-divider"><i class="bi bi-grip-horizontal"></i></div>

    <!-- Cards -->
    <div id="chart-panel" class="panel"></div>
  </div>
</main>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
  const DEBUG = false;

  /* ---------------------------------------
   * Globals
   * ------------------------------------- */
  const chartPanel  = document.getElementById('chart-panel');
  const clientPanel = document.getElementById('client-panel');
  const divider     = document.querySelector('.sidebar-divider');
  const searchInput = document.getElementById('clientSearch');
  const onlyCurrent = document.getElementById('onlyCurrent');
  const COLLAPSE_THRESHOLD = 60;

  const openCards = new Map(); // normalizedName -> card
  const normKey   = s => (s || '').trim().toLowerCase();

  /* --- Persistence (open charts + active tab) --- */
  const STORAGE_KEY = 'fig:charts:open-v1';
  function saveOpenState() {
    try {
      const state = Array.from(chartPanel.querySelectorAll('.chart-card')).map(card => {
        const name = card.dataset.client;
        const tabs = card.querySelectorAll('.tab-btn');
        let active = 0;
        tabs.forEach((b,i)=>{ if (b.classList.contains('active')) active = i; });
        return { name, activeTab: active };
      });
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch(e) { /* ignore */ }
  }
  async function restoreOpenState() {
    let state = [];
    try { state = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]') || []; } catch(e) {}
    for (const item of state) {
      try { await addCard(item.name, { initialTab: item.activeTab }); } catch(e) {}
    }
  }
  window.addEventListener('pagehide', saveOpenState);
  window.addEventListener('beforeunload', saveOpenState);

  /* Update flags beside a name in the sidebar */
  function setSidebarFlagsByName(clientName, flags){
    const cells = document.querySelectorAll('#client-panel td.client-name');
    let cell = null;
    for (const c of cells) {
      if ((c.dataset.name || '').trim() === clientName) { cell = c; break; }
    }
    if (!cell) return;
    let flagsEl = cell.querySelector('.client-flags');
    if (!flagsEl) {
      flagsEl = document.createElement('span');
      flagsEl.className = 'client-flags';
      cell.appendChild(flagsEl);
    }
    const { nutrition=false, focus=false } = flags || {};
    flagsEl.innerHTML = '';
    if (nutrition) flagsEl.insertAdjacentHTML('beforeend','<span title="Nutrition">üçé</span>');
    if (focus)     flagsEl.insertAdjacentHTML('beforeend','<span title="Focus Case">üéØ</span>');
  }

  /* ---------------------------------------
   * Sidebar filter
   * ------------------------------------- */
  function applyFilters() {
    const q    = (searchInput.value || '').toLowerCase();
    const only = !!(onlyCurrent && onlyCurrent.checked);
    document.querySelectorAll('#client-panel tbody tr').forEach(tr => {
      const nameCell = tr.querySelector('td.client-name');
      const nameText = (nameCell?.dataset.name || '').toLowerCase();
      const status   = (tr.dataset.status || '').toLowerCase();
      let show = true;
      if (q)    show = nameText.includes(q);
      if (only) show = show && (status === 'current client');
      tr.style.display = show ? '' : 'none';
    });
  }
  searchInput.addEventListener('input', applyFilters);
  onlyCurrent?.addEventListener('change', applyFilters);
  applyFilters();

  /* ---------------------------------------
   * Sidebar resize/collapse
   * ------------------------------------- */
  divider.addEventListener('mousedown', startDrag);
  divider.addEventListener('touchstart', startDrag);
  function startDrag(e){
    e.preventDefault(); document.body.style.cursor = 'ew-resize';
    const startX = e.touches ? e.touches[0].clientX : e.clientX;
    const startW = clientPanel.getBoundingClientRect().width;
    function onMove(ev){
      const x = ev.touches ? ev.touches[0].clientX : ev.clientX;
      const newW = Math.max(0, startW + (x - startX));
      clientPanel.style.width = `${newW}px`;
      const offset = newW < COLLAPSE_THRESHOLD
        ? COLLAPSE_THRESHOLD
        : (clientPanel.classList.remove('collapsed'), newW);
      if (newW < COLLAPSE_THRESHOLD) clientPanel.classList.add('collapsed');
      divider.style.left    = `${offset}px`;
      document.getElementById('chart-panel').style.left = `${offset}px`;
    }
    function onUp(){
      document.body.style.cursor = '';
      if (clientPanel.classList.contains('collapsed')){
        clientPanel.style.width = `${COLLAPSE_THRESHOLD}px`;
        divider.style.left      = `${COLLAPSE_THRESHOLD}px`;
        document.getElementById('chart-panel').style.left = `${COLLAPSE_THRESHOLD}px`;
      }
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('touchmove', onMove);
      window.removeEventListener('mouseup', onUp);
      window.removeEventListener('touchend', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove',  onMove);
    window.addEventListener('mouseup',    onUp);
    window.addEventListener('touchend',   onUp);
  }

  /* ---------------------------------------
   * Draggable divider between cards
   * ------------------------------------- */
  function makeDraggable(div, leftEl, rightEl){
    div.addEventListener('mousedown', startColDrag);
    div.addEventListener('touchstart', startColDrag);
    function startColDrag(e){
      e.preventDefault(); document.body.style.cursor = 'col-resize';
      const startX = e.touches ? e.touches[0].clientX : e.clientX;
      const leftW  = leftEl.getBoundingClientRect().width;
      const rightW = rightEl.getBoundingClientRect().width;
      function onMove(ev){
        const x = ev.touches ? ev.touches[0].clientX : ev.clientX;
        const dx = x - startX;
        const newL = leftW + dx, newR = rightW - dx;
        if (newL < 100 || newR < 100) return;
        leftEl.style.flex  = `0 0 ${newL}px`;
        rightEl.style.flex = `0 0 ${newR}px`;
      }
      function onUp(){
        document.body.style.cursor = '';
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('mouseup', onUp);
        window.removeEventListener('touchend', onUp);
      }
      window.addEventListener('mousemove', onMove);
      window.addEventListener('touchmove',  onMove);
      window.addEventListener('mouseup',    onUp);
      window.addEventListener('touchend',   onUp);
    }
  }
  function updateCardWidths(){
    const cards = chartPanel.querySelectorAll('.chart-card');
    if (!cards.length) return;
    const gap = 1;
    cards.forEach(c => c.style.flex = `0 0 calc((100% - ${gap*(cards.length-1)}rem)/${cards.length})`);
  }
  function rebuildCards(){
    chartPanel.querySelectorAll('.card-divider').forEach(d => d.remove());
    const cards = Array.from(chartPanel.querySelectorAll('.chart-card'));
    for (let i=0;i<cards.length-1;i++){
      const div = document.createElement('div');
      div.className = 'card-divider';
      div.innerHTML = '<i class="bi bi-grip-vertical"></i>';
      cards[i].after(div);
      makeDraggable(div, cards[i], cards[i+1]);
    }
    updateCardWidths();
  }

  /* ---------------------------------------
   * Debounce helper (with flush/cancel)
   * ------------------------------------- */
  function debounceSmart(fn, ms){
    let t=null, last=null, inFlight=null;
    const run = () => {
      inFlight = Promise.resolve().then(()=>fn(...(last||[]))).finally(()=>inFlight=null);
      last = null;
      return inFlight;
    };
    const w = (...args)=>{ last=args; clearTimeout(t); t=setTimeout(run, ms); };
    w.flush  = ()=>{ clearTimeout(t); t=null; return inFlight || (last ? run() : Promise.resolve()); };
    w.cancel = ()=>{ clearTimeout(t); t=null; last=null; };
    return w;
  }

  /* ---------------------------------------
   * Collectors
   * ------------------------------------- */
  function collectMeasuresFromCard(card){
    const out=[]; const tables=[...card.querySelectorAll('#measures table')]; if(!tables.length) return out;
    const grid=tables[0];
    grid.querySelectorAll('tbody tr').forEach(tr=>{
      const field=(tr.querySelector('th')?.textContent||'').trim(); if(!field) return;
      const tds=[...tr.querySelectorAll('td')]; const row={Field:field};
      if(field==='Notes'){ row['1']=(tds[0]?.textContent||'').trim(); for(let i=2;i<=20;i++) row[String(i)]=''; }
      else { for(let i=1;i<=20;i++) row[String(i)]=(tds[i-1]?.textContent||'').trim(); }
      out.push(row);
    });
    tables.slice(1).forEach(tbl=>{
      const heads=[...tbl.querySelectorAll('thead th')].map(th=>th.textContent.trim());
      tbl.querySelectorAll('tbody tr').forEach(tr=>{
        const row={}; const th=tr.querySelector('th'); if(th) row.Field=th.textContent.trim();
        const tds=[...tr.querySelectorAll('td')];
        heads.forEach((h,i)=>{ const key=h||`Col${i+1}`; row[key]=(tds[i]?.textContent||'').trim(); });
        out.push(row);
      });
    });
    return out;
  }
  function collectWorkoutFromCard(card){
    const pane=card.querySelector('#workout'); if(!pane) return [];
    const KG=pane.querySelector('#workout-kg')?.value.trim()||'';
    const Tools=pane.querySelector('#workout-tools')?.value.trim()||'';
    const Stretching=pane.querySelector('#stretching')?.value.trim()||'';
    const ringsTbl=[...pane.querySelectorAll('table')].find(t=>t.querySelector('thead th:nth-child(2)')?.textContent.trim()==='Workout');
    const ringHdrs=ringsTbl?[...ringsTbl.querySelectorAll('thead th')].map(th=>th.textContent.trim()):['#','Workout','Rings','Notes'];
    const ringRows=ringsTbl?[...ringsTbl.querySelectorAll('tbody tr')].map(tr=>{
      const tds=[...tr.querySelectorAll('td')]; const o={};
      ringHdrs.forEach((h,i)=>{ const td=tds[i], inp=td?.querySelector('input'); o[h]=(inp?inp.value:td?.textContent||'').trim(); });
      return o;
    }):[];
    const goldTbl=pane.querySelector('#goldorack-table');
    const goldRows=goldTbl?[...goldTbl.querySelectorAll('tbody tr')].map(tr=>{
      const [labelCell,valCell]=tr.querySelectorAll('td'); const inp=valCell?.querySelector('input');
      return { Goldorack:(labelCell?.textContent||'').trim()||'GK', Value:(inp?inp.value:valCell?.textContent||'').trim() };
    }):[];
    const data=[{KG,Tools,Stretching}];
    ringRows.forEach(r=>data.push({KG:'',Tools:'',Stretching:'',...r}));
    if(goldRows.length){ const blanks=ringHdrs.reduce((o,h)=>(o[h]='',o),{}); goldRows.forEach(r=>data.push({KG:'',Tools:'',Stretching:'',...blanks,...r})); }
    return data;
  }
  function collectNutritionFromCard(card){
    const rows=[]; card.querySelectorAll('#nutrition-rows .nutrition-row').forEach(el=>{
      const Date=el.querySelector('.nutrition-date')?.value.trim()||'';
      const Type=el.querySelector('.nutrition-type')?.value.trim()||'';
      const Notes=el.querySelector('.nutrition-notes')?.value.trim()||'';
      if(Date||Type||Notes) rows.push({Date,Type,Notes});
    }); return rows;
  }
  function collectCommunicationFromCard(card){
    const rows=[]; card.querySelectorAll('#comm-rows .comm-row').forEach(el=>{
      const Date=el.querySelector('.comm-date')?.value.trim()||'';
      const Type=el.querySelector('.comm-type')?.value.trim()||'';
      const Notes=el.querySelector('.comm-notes')?.value.trim()||'';
      if(Date||Type||Notes) rows.push({Date,Type,Notes});
    }); return rows;
  }
  function collectProfileFromCard(card){
    const pane=card.querySelector('#profile'); if(!pane) return {columns:[],data:[]};
    const months=['Jan','Feb','Mar','Apr','May','June','July','Aug','Sept','Oct','Nov','Dec'];
    const goals=pane.querySelector('textarea[name="goals"]')?.value.trim()||'';
    const initDate=pane.querySelector('input[name="init_date"]')?.value.trim()||'';
    const initWeight=pane.querySelector('input[name="init_weight"]')?.value.trim()||'';
    const lowestDate=pane.querySelector('input[name="lowest_date"]')?.value.trim()||'';
    const lowestWeight=pane.querySelector('input[name="lowest_weight"]')?.value.trim()||'';
    const targetDate=pane.querySelector('input[name="target_date"]')?.value.trim()||'';
    const targetWeight=pane.querySelector('input[name="target_weight"]')?.value.trim()||'';

    const nutriFlag = pane.querySelector('input[name="flag_nutrition"]')?.checked ? 'Yes' : 'No';
    const focusFlag = pane.querySelector('input[name="flag_focus_case"]')?.checked ? 'Yes' : 'No';

    let freq={}; const freqRow=pane.querySelector('caption + thead ~ tbody tr');
    if(freqRow){ const tds=[...freqRow.querySelectorAll('td')]; months.forEach((m,i)=>freq[m]=(tds[i]?.textContent||'').trim()); }
    const expiration=pane.querySelector('input[name="expiration"]')?.value.trim()||'';
    const firstSession=pane.querySelector('input[name="last_session"]')?.value.trim()||'';

    const profileRows=[
      {Field:'Goals',Value:goals},
      {Field:'Initial Weight',Date:initDate,Weight:initWeight},
      {Field:'Lowest Weight',Date:lowestDate,Weight:lowestWeight},
      {Field:'Target Weight',Date:targetDate,Weight:targetWeight},
      {Field:'Nutrition Flag', Flag:nutriFlag},
      {Field:'Focus Case Flag', Flag:focusFlag},
      {Field:'Expiration / Remaining',Value:expiration},
      {Field:'First Session Date',Value:firstSession}
    ];

    const blanks=Array(Math.max(0, 9-(1+profileRows.length+1))).fill({});
    const monthHdr=months.reduce((o,m)=>(o[m]=m,o),{Field:''});
    const freqRowObj=Object.assign({Field:'Frequency'},freq);
    const healthFields=[
      {key:'diabetes',label:'Diabetes'},
      {key:'bp',label:'Blood Pressure Issues'},
      {key:'vertigo',label:'Dizziness / Vertigo'},
      {key:'thyroid',label:'Thyroid Imbalances'},
      {key:'heart',label:'Heart Disease'},
      {key:'spine',label:'Back / Neck Issues'},
      {key:'hips',label:'Hips Issues'},
      {key:'legs',label:'Legs Issues'},
      {key:'arms',label:'Arms Issues'},
      {key:'vascular',label:'Vascular Pathologies'},
      {key:'irregular_period',label:'Irregular Menstrual Period / Hormonal Issues'},
      {key:'menopause_years',label:'Menopause ‚Äì # of Years'},
      {key:'blood_work',label:'Blood Work Alterations'}
    ];
    const healthRows = healthFields.map(f=>({
      Field:f.label,
      Flag: pane.querySelector(`input[name="flag_${f.key}"]`)?.checked?'Yes':'No',
      Comment: pane.querySelector(`input[name="comment_${f.key}"]`)?.value?.trim()||''
    }));
    const rewardRows=[...pane.querySelectorAll('#rewards-table tbody tr')].map(tr=>{
      const used=tr.querySelector('input[name="used[]"]')?.checked?'Yes':'No';
      const [,deal,notes]=[...tr.querySelectorAll('td')];
      return {Field:'Reward / Deal',Used:used,RewardDeal:(deal?.textContent||'').trim(),RewardNotes:(notes?.textContent||'').trim()};
    });
    const friendRows=[...pane.querySelectorAll('#friends-table tbody tr')].map(tr=>{
      const sel=tr.querySelector('input[name="friend-selected[]"]')?.checked?'Yes':'No';
      const [,name,notes]=[...tr.querySelectorAll('td')];
      return {Field:'Friend',Select:sel,FriendName:(name?.textContent||'').trim(),FriendNotes:(notes?.textContent||'').trim()};
    });
    const columns=['Field','Value','Flag','Comment','Date','Weight',...months,'Used','RewardDeal','RewardNotes','Select','FriendName','FriendNotes'];
    return {columns, data:[...profileRows,...blanks,monthHdr,freqRowObj,...healthRows,{}, {Field:'Rewards / Deals'}, ...rewardRows, {}, {Field:'Friends'}, ...friendRows]};
  }

  /* ---------------------------------------
   * Autosave wiring ‚Äî event delegation + pill visuals
   * ------------------------------------- */
  function wireAutosaveForCard(card, clientName){
    const saveCore = async ()=>{
      const sheets = {
        profile:       collectProfileFromCard(card) || {columns:[],data:[]},
        measures:      { data: collectMeasuresFromCard(card) || [] },
        workout:       { data: collectWorkoutFromCard(card)  || [] },
        nutrition:     { columns:['Date','Type','Notes'], data: collectNutritionFromCard(card) || [] },
        communication: { columns:['Date','Type','Notes'], data: collectCommunicationFromCard(card) || [] },
      };
      if (DEBUG) console.debug('[save ‚ñ∂]', clientName);
      const res = await fetch(`/charts/client/${encodeURIComponent(clientName)}/save`, {
        method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ sheets })
      });
      const j = await res.json().catch(()=>({}));
      if (!res.ok || j.status!=='success') throw new Error(j.message||`HTTP ${res.status}`);
      if (DEBUG) console.debug('[save ‚úì]', clientName);
    };

    const deb = debounceSmart(saveCore, 700);
    card.__saveDebounced = deb;
    const maybeSave = ()=> deb();

    /* --- pill helpers --- */
    function checkboxFor(btn){
      let name = btn.dataset.flag;
      if (!name){
        const txt = (btn.textContent || '').toLowerCase();
        if (txt.includes('nutrition')) name = 'flag_nutrition';
        else if (txt.includes('focus')) name = 'flag_focus_case';
      }
      return name ? card.querySelector(`input[name="${name}"]`) : null;
    }
    function renderPills(){
      card.querySelectorAll('.flag-group .flag-btn').forEach(btn=>{
        const chk = checkboxFor(btn);
        const on = !!chk?.checked;
        btn.setAttribute('aria-pressed', on ? 'true' : 'false');
        btn.classList.toggle('btn-on',  on);
        btn.classList.toggle('btn-off', !on);
      });
    }
    function syncSidebar(){
      const nutri = !!card.querySelector('input[name="flag_nutrition"]')?.checked;
      const focus = !!card.querySelector('input[name="flag_focus_case"]')?.checked;
      setSidebarFlagsByName(clientName, { nutrition:nutri, focus:focus });
    }

    // Delegated inputs ‚Üí autosave
    const delegatedHandler = (e)=>{
      const el = e.target;
      if (!(el instanceof HTMLElement)) return;
      if (el.matches('input, textarea, [contenteditable="true"]')) maybeSave();
    };
    card.addEventListener('input', delegatedHandler, true);
    card.addEventListener('change', delegatedHandler, true);
    card.addEventListener('blur', delegatedHandler, true);
    card.__delegatedHandler = delegatedHandler;

    // Delegated pill click
    card.addEventListener('click', (e)=>{
      const btn = e.target.closest('.flag-group .flag-btn');
      if (!btn) return;
      e.preventDefault();
      const chk = checkboxFor(btn);
      if (chk){
        chk.checked = !chk.checked;
        chk.dispatchEvent(new Event('change', { bubbles:true }));
        renderPills();
        syncSidebar();
        maybeSave();
      }
    });

    // Checkbox direct changes
    const nutri = card.querySelector('input[name="flag_nutrition"]');
    const focus = card.querySelector('input[name="flag_focus_case"]');
    nutri?.addEventListener('change', ()=>{ renderPills(); syncSidebar(); maybeSave(); });
    focus?.addEventListener('change', ()=>{ renderPills(); syncSidebar(); maybeSave(); });

    // Initial paint
    renderPills();
    syncSidebar();

    card.addEventListener('card:close', ()=> deb.flush().catch(()=>{}));
  }

  /* ---------------------------------------
   * Tabs + scaling
   * ------------------------------------- */
  function initTabs(card, initialIndex=0){
    const tabs = card.querySelectorAll('.tab-btn');
    const panes = card.querySelectorAll('.tab-content');
    const underline = card.querySelector('#tabUnderline');
    if (!tabs.length || !underline) return;

    function activate(i){
      tabs.forEach((b,j)=>b.classList.toggle('active', j===i));
      panes.forEach((p,j)=>p.classList.toggle('hidden', j!==i));
      const r = tabs[i].getBoundingClientRect();
      const pr = tabs[i].parentElement.getBoundingClientRect();
      underline.style.width = `${r.width}px`;
      underline.style.left  = `${r.left - pr.left}px`;
      saveOpenState(); // persist active tab
    }

    tabs.forEach((btn,i)=>btn.addEventListener('click', ()=>{
      activate(i);
      const cardEl = btn.closest('.chart-card');
      cardEl?.__saveDebounced?.();
      requestAnimationFrame(()=>scaleChart(cardEl));
    }));
    activate(Math.max(0, Math.min(initialIndex, tabs.length-1)));
  }

  function scaleChart(card){
    const tgt = card.querySelector('.scale-target');
    const cnt = card.querySelector('.scale-content');
    if (!tgt || !cnt) return;

    cnt.style.overflow = 'auto';
    cnt.classList.add('hide-scrollbar');
    cnt.style.width  = '100%';
    cnt.style.height = '100%';
    cnt.style.webkitOverflowScrolling = 'touch';

    tgt.style.transformOrigin = 'top left';
    const sX = card.clientWidth  / cnt.scrollWidth;
    const sY = card.clientHeight / cnt.scrollHeight;
    const s  = Math.min(sX, sY, 1);
    tgt.style.transform = `scale(${s})`;
  }

  function setupScaling(card){
    requestAnimationFrame(()=>scaleChart(card));
    const ro = new ResizeObserver(()=>requestAnimationFrame(()=>scaleChart(card)));
    ro.observe(card);
    const cnt = card.querySelector('.scale-content');
    if (cnt) ro.observe(cnt);
    card.querySelectorAll('img').forEach(img=>img.addEventListener('load', ()=>scaleChart(card), {once:true}));
    card.__ro = ro;
  }

  /* ---------------------------------------
   * Load a card‚Äôs HTML (strip all <script> tags)
   * ------------------------------------- */
  async function loadCardContent(card, name, initialTab=0){
    const key = normKey(name);
    const controller = new AbortController();
    card.__abortController = controller;

    try{
      const res = await fetch(`/charts/client/${encodeURIComponent(name)}`, { signal: controller.signal, cache:'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const html = await res.text();
      if (openCards.get(key) !== card) return;

      const body = card.querySelector('.chart-body');

      const wrapper = document.createElement('div');
      wrapper.innerHTML = html;
      wrapper.querySelectorAll('script').forEach(s => s.remove()); // prevent duplicate inits

      body.innerHTML = '';
      const frag = document.createDocumentFragment();
      Array.from(wrapper.childNodes).forEach(n => frag.appendChild(n));
      body.appendChild(frag);

      initTabs(card, initialTab);
      setupScaling(card);
      wireAutosaveForCard(card, name);
      saveOpenState(); // persist after load
    }catch(err){
      if (!controller.signal.aborted){
        const body = card.querySelector('.chart-body');
        body.innerHTML = '<div style="padding:1rem;color:#b91c1c">Failed to load. Click to retry.</div>';
        body.addEventListener('click', ()=> loadCardContent(card, name, initialTab), { once:true });
        console.error('Load error:', err);
      }
    }finally{
      delete card.__abortController;
    }
  }

  /* ---------------------------------------
   * Add a card (opts: { initialTab })
   * ------------------------------------- */
  async function addCard(name, opts={}){
    const key = normKey(name);
    if (!key) return;

    if (openCards.has(key)){
      const existing = openCards.get(key);
      existing.scrollIntoView({behavior:'smooth', block:'nearest', inline:'nearest'});
      const hdr=existing.querySelector('.chart-header'); hdr?.classList.add('flash'); setTimeout(()=>hdr?.classList.remove('flash'),800);
      return;
    }
    if (chartPanel.querySelectorAll('.chart-card').length >= 4) return;

    const card = document.createElement('div');
    card.className = 'chart-card panel';
    card.dataset.client = name;
    card.innerHTML = `
      <div class="scale-target">
        <div class="scale-content">
          <div class="chart-header">
            <span class="truncate">${name}</span>
            <span>
              <button class="chart-edit" title="Highlight Edit Mode">‚úé</button>
              <button class="chart-close" title="Close">√ó</button>
            </span>
          </div>
          <div class="chart-body">Loading...</div>
        </div>
      </div>`;
    chartPanel.appendChild(card);
    openCards.set(key, card);
    rebuildCards();

    card.querySelector('.chart-edit').addEventListener('click', ()=> card.classList.toggle('editing'));
    card.querySelector('.chart-close').addEventListener('click', async ()=>{
      try { await card.__saveDebounced?.flush(); } catch(e) {}
      card.dispatchEvent(new CustomEvent('card:close'));
      if (card.__delegatedHandler){
        card.removeEventListener('input',  card.__delegatedHandler, true);
        card.removeEventListener('change', card.__delegatedHandler, true);
        card.removeEventListener('blur',   card.__delegatedHandler, true);
      }
      if (card.__ro) { try{ card.__ro.disconnect(); }catch(_){} }
      if (card.__abortController) { try{ card.__abortController.abort(); }catch(_){} }
      openCards.delete(key);
      card.remove();
      rebuildCards();
      saveOpenState(); // persist after close
    });

    await loadCardContent(card, name, Number.isInteger(opts.initialTab) ? opts.initialTab : 0);
  }

  /* ---------------------------------------
   * Open from sidebar
   * ------------------------------------- */
  document.getElementById('client-panel').addEventListener('click', e => {
    const td = e.target.closest('td.client-name'); if (!td) return;
    addCard(td.dataset.name).then(saveOpenState);
  });

  window.addEventListener('resize', () => {
    updateCardWidths();
    chartPanel.querySelectorAll('.chart-card').forEach(scaleChart);
  });

  /* Restore previously open charts */
  restoreOpenState();
});
</script>
{% endblock %}
